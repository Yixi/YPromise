<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Ypromise by Yixi</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Ypromise</h1>
      <h2 class="project-tagline">A javascript promise library</h2>
      <a href="https://github.com/Yixi/YPromise" class="btn">View on GitHub</a>
      <a href="https://github.com/Yixi/YPromise/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/Yixi/YPromise/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="ypromise" class="anchor" href="#ypromise" aria-hidden="true"><span class="octicon octicon-link"></span></a>YPromise</h1>

<p>基于 <a href="http://wiki.commonjs.org/wiki/Promises">Common JS Promises/A</a> 建议的js异步编程库，提供一种Promise机制来管理js中的异步交互。</p>

<h2>
<a id="使用" class="anchor" href="#%E4%BD%BF%E7%94%A8" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用</h2>

<pre>
function fun3(){
     return new YPro(function(comp,err){
        setTimeout(function(){
             comp('fun3 done');
        },3000);
     })
}
function fun4(){
     return new YPro(function(comp,err){
        setTimeout(function(){
             comp('fun4 done');
        },1000);
     })
}
var aPromise = fun3()
                .then(function(d){console.log(d); return fun4();})
                .then(function(){return fun3();})
                .then(function(){return fun4();})
                .done(function(){
                    console.log("fun3-&gt;fun4-&gt;fun3-&gt;fun4 done");
                })

setTimeout(function(){
    aPromise.cancel(function(){
        console.log("Promise canceled");
    });
},9000);

</pre>

<h2>
<a id="api" class="anchor" href="#api" aria-hidden="true"><span class="octicon octicon-link"></span></a>API</h2>

<p>如果你以前使用过window8开发中的WinJS.promise对象，你可以快速上手。</p>

<h3>
<a id="yprofunction-or-ypromisefunction-构造器" class="anchor" href="#yprofunction-or-ypromisefunction-%E6%9E%84%E9%80%A0%E5%99%A8" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>YPro(Function)</code> or <code>YPromise(Function)</code> 构造器</h3>

<p>初始化一个promise对象,其中YPro提供一个对YPromise的简洁访问</p>

<pre>
var aPromise = new YPromise(init);
</pre>

<p>init方法中可传入三个参数，后面两个为可选</p>

<ul>
<li>
<em>completeDispatch</em> 初始化代码中操作完成后需要调用这个函数传递结果</li>
<li>
<em>errorDispatch</em> 当发生错误时需要调用这方法传递错误</li>
<li>
<em>progressDispatch</em> 如果异步操作需要支持进度条，初始化代码应该定期调用这个功能，并传递一个进度中间值</li>
</ul>

<p>你需要使用这个返回一个promise对象来包裹你的异步函数</p>

<pre>
/*example for constructor*/

function fn1(){
    return new YPro(function(comp,err,prog){
        var i = 0;
        function sleep(){
            i++;
            if(i&gt;100){
                comp('fun1 done');
            }else{
                prog(i);
                setTimeout(function(){
                    sleep();
                },100);
            }           
        }
        sleep();
    });
}
</pre>

<h3>
<a id="then" class="anchor" href="#then" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>.then</code>
</h3>

<p>指定promise完成后执行的函数，如果promise未完成则进行错误处理，以及处理进度变化通知</p>

<pre>
YPro.then(onComplete, onError, onProgress).done();
</pre>

<p>参数:</p>

<ul>
<li>
<em>onComplete</em> promise成功后将会执行此方法，参数来自构造函数中的 <em>completeDispatch</em> 传递</li>
<li>
<em>onError</em> promise发生错误将会调用此方法</li>
<li>
<em>onProgress</em> 如果promise函数中有来自 <em>progressDispatch</em> 调用将会触发此方法</li>
</ul>

<p>返回：
该方法将会返回一个 <code>YPromise</code> 对象</p>

<pre>
var PromiseA = fun1()
    .then(
        function(data){
            console.log(data);
        },
        function(error){
            console.error(error);
        },
        function(prog){
            console.log(prog+"%");
        }
    );
</pre>

<h3>
<a id="done-待完善" class="anchor" href="#done-%E5%BE%85%E5%AE%8C%E5%96%84" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>.done</code> (待完善)</h3>

<p>提供和then一样的作用，此方法不会传递错误值，将会把异常直接抛出</p>

<pre>
YPro.done(omComplete);
</pre>

<h3>
<a id="ypromisejoin" class="anchor" href="#ypromisejoin" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>YPromise.join</code>
</h3>

<p>合并多个promise，当所有Promise完成后将会执行then方法，返回对应位置promise的返回，若promise返回参数多于一个，将会以数组的形式传递返回。</p>

<pre>
YPro.join(promise1,promise2,...).then(onComplete);
</pre>

<p>参数：
一个或多个YPromsie对象</p>

<p>返回：该方法将会返回一个<code>YPromise</code>对象</p>

<pre>
var PromiseAll = YPro.join(fn1(),fn2())
            .then(function(data1,data2){
                console.log(data1,data2);
            })
</pre>

<h3>
<a id="ypromisequeue" class="anchor" href="#ypromisequeue" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>YPromise.queue</code>
</h3>

<p>执行一个返回Ypromise的队列方法</p>

<pre>
 YPromise.queue(array,isOrder).then()
</pre>

<p>该方法传入两个参数，第二个参数为可选</p>

<ul>
<li>
<em>array</em> 一个待执行包含返回promise对象的function数组</li>
<li>
<em>isOrder</em> 默认false，若为true，将会按顺序执行array队列中的方法，且设置为true后，将会把单个方法错误信息放到onComplete回调中</li>
</ul>

<p>返回，该方法返回一个 <code>Ypromise</code> 对象</p>

<pre lang="javascript```"><code>var args = [];
for(var i=0;i&lt;50; i++){
    args.push(i);
}

var taskList = args.map(function(arg){
    return function(){
        return new YPro(function(comp,err,prog){
        setTimeout(function(){
            console.log('in function',arg);
            comp('callback '+arg);
        },300);
        });
    };
});

YPro.queue(taskList)
    .then(function(){
        cosole.log(arguments);
        return YPro.queue(taskList,true);
    })
    .then(function(){
        console.log(arguments);
    });

</code></pre>

<h3>
<a id="ypromiseany" class="anchor" href="#ypromiseany" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>YPromise.any</code>
</h3>

<p>用法类似<code>YPromise.join</code>,但不需要等待所有proimise完成，一旦其中任意一个promise完成将会立即传递这个promise的返回值。</p>

<pre>
YPro.any(promise1,promise2,…).then(onComplete);
</pre>

<p>返回，该方法返回一个<code>YPromise</code>对象</p>

<pre>
var PromiseAny = YPro.join(fn1(),fn2())
            .then(function(data){
                console.log(data);
            });
</pre>

<h3>
<a id="ypromiseas" class="anchor" href="#ypromiseas" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>YPromise.as</code>
</h3>

<p>此方法将会把同步方法以Promise的方式调用,以解决特殊时候需求</p>

<pre>
YPro.as(Function).then(onComplete);
</pre>

<p>返回：该方法将会返回一个<code>YPromise</code>对象</p>

<pre>
function fn5(){
    return 'function 5 done';
}
var PromiseAs = YPro.as(fn5())
            .then(function(data){
                console.log(data);
            });

</pre>

<h3>
<a id="ypromisecancel" class="anchor" href="#ypromisecancel" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>YPromise.cancel</code>
</h3>

<p>调用该方法将会取消promise链的向下执行</p>

<pre>
YPromsise.cancel();
</pre>

<hr>

<p>更多用法请参考/example例子</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/Yixi/YPromise">Ypromise</a> is maintained by <a href="https://github.com/Yixi">Yixi</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>

